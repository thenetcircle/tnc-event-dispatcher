#!/usr/bin/env php
<?php
foreach (array(
             __DIR__.'/../../autoload.php',
             __DIR__.'/../vendor/autoload.php',
             __DIR__.'/vendor/autoload.php',
         ) as $file) {
    if (file_exists($file)) {
        define('COMPOSER_AUTOLOAD_FILE', $file);
        break;
    }
}
unset($file);

if (!defined('COMPOSER_AUTOLOAD_FILE')) {
    fwrite(
        STDERR,
        'You need to set up the project dependencies using the following commands:'.PHP_EOL.'wget http://getcomposer.org/composer.phar'.PHP_EOL.'php composer.phar install'.PHP_EOL
    );
    die(1);
}
require COMPOSER_AUTOLOAD_FILE;

use \Tnc\Service\EventDispatcher\Consumer;
use \Tnc\Service\EventDispatcher\EventWrapper;
use \Tnc\Service\EventDispatcher\Exception\NoDataException;
use \Tnc\Service\EventDispatcher\Exception\TimeoutException;
use \Tnc\Service\EventDispatcher\Exception\FatalException;
use \Tnc\Service\EventDispatcher\Tests\Mock\MockExternalDispatcher;
use \Tnc\Service\EventDispatcher\ChannelDetective\SimpleChannelDetective;
use \Tnc\Service\EventDispatcher\Backend\KafkaBackend;
use \Tnc\Service\EventDispatcher\Pipeline;
use \Tnc\Service\EventDispatcher\Serializer\DefaultSerializer;
use \Ko\Process;

if ($argc < 3) {
    die('Usage: ./consumer brokers workerNum [processTitle]'.PHP_EOL);
}

$brokers      = $argv[1];
$workerNum    = $argv[2];
$processTitle = $argv[3] ?: 'EventDispatcher';

$job = function (Process $process) use ($brokers) {

    // bootstrap
    $externalDispatcher = new MockExternalDispatcher();
    $pipeline           = new Pipeline(new KafkaBackend($brokers, [], false), new DefaultSerializer(), new SimpleChannelDetective());
    $listeningChannels  = null; // if null, will listen default channels from ChannelDetective

    $initFilemtime = filemtime(__FILE__);
    $acceptedJobs = 0;
    $failedJobs   = 0;

    // start working
    while (true) {

        // check if code is changed, usually for redeployment
        if (filemtime(__FILE__) !== $initFilemtime) {
            sleep(5);
            exit(1);
        }

        try {
            /** @var EventWrapper $eventWrapper */
            list($eventWrapper, $receipt) = $pipeline->pop(500000, $listeningChannels);
            $acceptedJobs++;

            if ($eventWrapper === null) {
                debugLog(
                    sprintf(
                        'Got null event from pipeline, Receipt: %s.',
                        serialize($receipt)
                    )
                );
            } else {
                $event = $eventWrapper->getEvent();
                // only accepts TncEvent instances
                /*if (!$event instanceof TncEvent) {
                    continue;
                }*/
                // only accepts ASYNC events
                /*if ($event->getMode() !== TncEvent::MODE_ASYNC) {
                    continue;
                }*/
                // if there is no listeners for the event, just skip it
                /*if (!$externalDispatcher->getListeners($event->getName())) {
                    continue;
                }*/
                try {
                    // Optimize receipt
                    debugLog(
                        sprintf(
                            'Got a new event %s, Total: %d, Topic: %s, Partition: %d, LastOffset: %d.',
                            get_class($event),
                            $acceptedJobs,
                            $receipt->topic_name,
                            $receipt->partition,
                            $receipt->offset
                        )
                    );

                    // TODO dispatch events to listeners

                    $pipeline->ack($receipt);
                } catch (\Exception $e) {
                    // TODO handler failed jobs
                    debugLog(
                        sprintf(
                            'Job execute failed, ErrorCode: %d, ErrorMessage: %s.',
                            $e->getCode(),
                            $e->getMessage()
                        )
                    );
                }
            }
        } catch (NoDataException $e) {
            debugLog('There is no data in upstream backend.');
        } catch (TimeoutException $e) {
            debugLog('Fetch data from upstream backend timeout, will try it again.');
        } catch (FatalException $e) {
            $failedJobs++;
            debugLog(
                sprintf(
                    'Fetch data from upstream backend failed %d times, ErrorCode: %d, ErrorMessage: %s.',
                    $failedJobs,
                    $e->getCode(),
                    $e->getMessage()
                )
            );
            // sleep 1 second before retry
            sleep(1);
        }

        if ($failedJobs >= 10 || $acceptedJobs >= 10000) {
            debugLog(
                sprintf(
                    'Exceed the limitation, FailedJobs %d, AcceptedJobs: %d, Will exit.',
                    $failedJobs,
                    $acceptedJobs
                )
            );
            // sleep 5 seconds then exit, to protect that worker process will be auto-restarted
            sleep(5);
            exit(1);
        }

        // dispatch pending signals
        $process->dispatch();
        if ($process->isShouldShutdown()) {
            exit();
        }
    }
};

function debugLog($message)
{
    echo "[".posix_getpid()."] ".$message.PHP_EOL;
    ob_flush();
}

(new Consumer($job, $workerNum, $processTitle))->run();