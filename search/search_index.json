{
    "docs": [
        {
            "location": "/",
            "text": "Background\n\n\nEvent Dispatcher is a core function of Symfony Framework since very earlier version, For other PHP frameworks as well.\n\nIt's a very cool and effecient idea for decoupling modules or functions.\n\n\nsymfony-event-dispatcher\n is one of most popular Event Dispatcher implementations in PHP world. It's also being used on other PHP frameworks.\n\n\nWhat's tnc-event-dispatcher?\n\n\ntnc-event-dispatcher is a alternative of \nsymfony-event-dispatcher\n for supporting asynchronous and unified structured events. It works as same as symfony-event-dispatcher, has same user interface with a few more options, can replace symfony-event-dispatcher seamlessly.  \n\n\n \n\n\nUser cases of tnc-event-dispatcher:\n\n\n\n\nHeavy Listeners\n\n\nDistrubuted Listeners\n\n\nShared Events across multiple systems\n\n\nStructred data collecting\n\n\n...\n\n\n\n\ntnc-event-dispatcher includes following core components: \nDispatcher\n, \nSerializer\n, \nEndPoint\n, \nReceiver\n.\n\nIt is highly inspired by symfony-event-dispatcher, But not limited on that, symfony-event-dispatcher is one of the Dispatcher implementations of tnc-event-dispatcher, It intends to support other Event Dispatcher implementations as well. \n\n\nHow to install?\n\n\nRequirements\n\n\n\n\nPHP 5.6+\n\n\n\n\nInstall From Composer\n\n\n> composer install tnc/event-dispatcher\n\n\n\n\nHow to use?\n\n\n<?php\nnamespace TNC\\EventDispatcher;\n\ntry {\n    /**\n     * 1. Initialize Serializer\n     * \n     * Serializer is using to serialize your event to be a string.\n     * It includes a couple of Normalizers and a Formatter.\n     */     \n    # Specify Normalizers\n    $supportedNormalizers = [\n        new Serialization\\Normalizers\\TNCActivityStreams\\TNCActivityStreamsWrappedEventNormalizer(),\n        new Serialization\\Normalizers\\TNCActivityStreams\\TNCActivityStreamsNormalizer()\n    ];\n    # Specify Serialization Format\n    $formatter  = new Serialization\\Formatters\\JsonFormatter();\n    # Initialize Serializer\n    $serializer = new Serializer($supportedNormalizers, $formatter);\n\n\n    /**\n     * 2. Initialize EndPoint\n     * \n     * If you are going to dispatch a async event, which needs a EndPoint to hold the request and send back to Receiver.\n     * Mostly the EndPoint is a Queue, such as Redis, Rabbitmq, Kafka or EventBus (https://github .com/thenetcircle/event-bus)\n     */\n    $endPoint = new EndPoints\\EventBusEndPoint('http://localhost:8000');\n\n\n    /**\n     * 3. Initialize tnc-event-dispatcher, And add some Listeners\n     */\n    $dispatcher = new Dispatchers\\SymfonyImpl\\EventDispatcher($serializer, $endPoint);\n    # Suppose we have a Symfony Event Listener and a Event Subscriber here\n    $dispatcher->addListener('message.send', new SymfonyEventListener());\n    $dispatcher->addSubscriber(new SymfonyEventSubscriber());\n\n    /**\n     * 4. Dispatch Events\n     */\n    $dispatcher->dispatch(\n        'message.send',\n        new AsyncEvent(\n            [\n                'messageId'   => '1',\n                'messageBody' => 'abc'\n            ]\n        )\n    );\n}\ncatch (\\Exception $e) {\n    // Handling Exception\n}\n\n/**\n * 5. Receiving and handling the AsyncEvent\n * \n * After the Event dispatched to the EndPoint, It will be delivered to the Receiver asynchronously.\n * Following are Receiver part, Which could be running on another PHP process\n */\ntry {\n    # Initialize a Receiver(use EventBusReceiver as a example here, could be RabbitMQReceiver, RedisReceiver, ...)\n    $receiver = new Receivers\\EventBusReceiver();\n    # Set Dispatcher we defined before\n    $receiver->withDispatcher($dispatcher);\n    # Dispatch the serliazed-event we received from the EndPoint\n    $receiver->dispatch($serliazedEvent);\n}\ncatch (\\Exception $e) {\n    // Handling Exception\n}\n\n\n\n\nAbout Contributing\n\n\nFeedbacks and pull requests are welcome and appreciative. For major changes, please open an issue first to discuss what you would like to change.\n\n\nChange Logs\n\n\nClick to check Change Logs",
            "title": "Overview"
        },
        {
            "location": "/#background",
            "text": "Event Dispatcher is a core function of Symfony Framework since very earlier version, For other PHP frameworks as well. \nIt's a very cool and effecient idea for decoupling modules or functions.  symfony-event-dispatcher  is one of most popular Event Dispatcher implementations in PHP world. It's also being used on other PHP frameworks.",
            "title": "Background"
        },
        {
            "location": "/#whats-tnc-event-dispatcher",
            "text": "tnc-event-dispatcher is a alternative of  symfony-event-dispatcher  for supporting asynchronous and unified structured events. It works as same as symfony-event-dispatcher, has same user interface with a few more options, can replace symfony-event-dispatcher seamlessly.       User cases of tnc-event-dispatcher:   Heavy Listeners  Distrubuted Listeners  Shared Events across multiple systems  Structred data collecting  ...   tnc-event-dispatcher includes following core components:  Dispatcher ,  Serializer ,  EndPoint ,  Receiver . \nIt is highly inspired by symfony-event-dispatcher, But not limited on that, symfony-event-dispatcher is one of the Dispatcher implementations of tnc-event-dispatcher, It intends to support other Event Dispatcher implementations as well.",
            "title": "What's tnc-event-dispatcher?"
        },
        {
            "location": "/#how-to-install",
            "text": "",
            "title": "How to install?"
        },
        {
            "location": "/#requirements",
            "text": "PHP 5.6+",
            "title": "Requirements"
        },
        {
            "location": "/#install-from-composer",
            "text": "> composer install tnc/event-dispatcher",
            "title": "Install From Composer"
        },
        {
            "location": "/#how-to-use",
            "text": "<?php\nnamespace TNC\\EventDispatcher;\n\ntry {\n    /**\n     * 1. Initialize Serializer\n     * \n     * Serializer is using to serialize your event to be a string.\n     * It includes a couple of Normalizers and a Formatter.\n     */     \n    # Specify Normalizers\n    $supportedNormalizers = [\n        new Serialization\\Normalizers\\TNCActivityStreams\\TNCActivityStreamsWrappedEventNormalizer(),\n        new Serialization\\Normalizers\\TNCActivityStreams\\TNCActivityStreamsNormalizer()\n    ];\n    # Specify Serialization Format\n    $formatter  = new Serialization\\Formatters\\JsonFormatter();\n    # Initialize Serializer\n    $serializer = new Serializer($supportedNormalizers, $formatter);\n\n\n    /**\n     * 2. Initialize EndPoint\n     * \n     * If you are going to dispatch a async event, which needs a EndPoint to hold the request and send back to Receiver.\n     * Mostly the EndPoint is a Queue, such as Redis, Rabbitmq, Kafka or EventBus (https://github .com/thenetcircle/event-bus)\n     */\n    $endPoint = new EndPoints\\EventBusEndPoint('http://localhost:8000');\n\n\n    /**\n     * 3. Initialize tnc-event-dispatcher, And add some Listeners\n     */\n    $dispatcher = new Dispatchers\\SymfonyImpl\\EventDispatcher($serializer, $endPoint);\n    # Suppose we have a Symfony Event Listener and a Event Subscriber here\n    $dispatcher->addListener('message.send', new SymfonyEventListener());\n    $dispatcher->addSubscriber(new SymfonyEventSubscriber());\n\n    /**\n     * 4. Dispatch Events\n     */\n    $dispatcher->dispatch(\n        'message.send',\n        new AsyncEvent(\n            [\n                'messageId'   => '1',\n                'messageBody' => 'abc'\n            ]\n        )\n    );\n}\ncatch (\\Exception $e) {\n    // Handling Exception\n}\n\n/**\n * 5. Receiving and handling the AsyncEvent\n * \n * After the Event dispatched to the EndPoint, It will be delivered to the Receiver asynchronously.\n * Following are Receiver part, Which could be running on another PHP process\n */\ntry {\n    # Initialize a Receiver(use EventBusReceiver as a example here, could be RabbitMQReceiver, RedisReceiver, ...)\n    $receiver = new Receivers\\EventBusReceiver();\n    # Set Dispatcher we defined before\n    $receiver->withDispatcher($dispatcher);\n    # Dispatch the serliazed-event we received from the EndPoint\n    $receiver->dispatch($serliazedEvent);\n}\ncatch (\\Exception $e) {\n    // Handling Exception\n}",
            "title": "How to use?"
        },
        {
            "location": "/#about-contributing",
            "text": "Feedbacks and pull requests are welcome and appreciative. For major changes, please open an issue first to discuss what you would like to change.",
            "title": "About Contributing"
        },
        {
            "location": "/#change-logs",
            "text": "Click to check Change Logs",
            "title": "Change Logs"
        },
        {
            "location": "/dispatcher/",
            "text": "Summary\n\n\nDispatcher is the user interface of tnc-event-dispatcher, It holds Serializer and EndPoint, binds Listeners, accepts Event and dispatches them to corresponding Listeners or EndPoint.\n\n\ntnc-event-dispatcher\n is gonna to have multiple Dispatcher implementations to adapte different frameworks. Currently only Symfony Event Dispatcher is implemented. \n\n\nSymfony Event Dispatcher\n\n\nSymfony Event Dispatcher Implementation intends to replace the original symfony-event-dispatcher seamlessly.\n\nThey have similar user interface, Just some more extra options.\n\n\nDefine a Event\n\n\nFor Event port, The original Events are fully supported without any changes. Just define the event and dispatch it.\n\nBut there are some more event types tnc-event-dispatcher supports. They are:\n\n\n\n\nsync\n\n  works as same as origin event, the event will be dispatched to listeners directly.\n\n\nsync_plus \n\n  same as \"sync\" mode, except that after the event has been dispatched to local listeners, i will also send to EndPoint for remote listeners, but it will not be dispatched to local listeners again.\n\n\nasync\n\n  the event will be sent to EndPoint only, and after the receiver got it, will be dispatched to listeners.\n\n\nboth\n\n  the event will be dispatched to local listeners who are listening on the event name, and then send to EndPoint as well, after the receiver got it, will be dispatched to listeners who are listening on \"$eventName.async\"\n\n\n\n\nLet's define a AsyncEvent, Which is as same as Symfony Event with implements TransportableEvent interface(have to implement getTransportMode method to specify the type of the Event).\n\n\n<?php\nuse Symfony\\Component\\EventDispatcher\\Event;\nuse TNC\\EventDispatcher\\Interfaces\\Event\\TransportableEvent;\n\n/**\n * AsyncEvent will be send to the EndPoint\n */\nclass AsyncEvent extends Event implements TransportableEvent\n{\n    const NAME = 'message.send';\n\n    private $data = [];\n\n    public function __construct($data)\n    {\n        $this->data = $data;\n    }\n\n    /**\n     * Returns transport mode of this event\n     *\n     * It supports one of these:\n     *\n     *  - \"sync\"      works as same as origin event, the event will be dispatched to listeners directly.\n     *\n     *  - \"sync_plus\" same as \"sync\" mode, except that after the event has been dispatched to local listeners, i will\n     *                also send to EndPoint for remote listeners, but it will not be dispatched to local listeners\n     *                again.\n     *\n     *  - \"async\"     the event will be sent to EndPoint only, and after the receiver got it, will be dispatched to\n     *                listeners.\n     *\n     *  - \"both\"      the event will be dispatched to local listeners who are listening on the event name, and then\n     *                send to EndPoint as well, after the receiver got it, will be dispatched to listeners who are\n     *                listening on \"$eventName.async\"\n     *\n     * @see \\TNC\\EventDispatcher\\Interfaces\\Event\\TransportableEvent\n     *\n     * @return string\n     */\n    public function getTransportMode()\n    {\n        // TODO: Implement getTransportMode() method.\n    }\n}\n\n\n\n\nDispatch the Event\n\n\nDispatcher has totally same interface of symfony-event-dispatcher\n\n\n<?php\n# Initialize tnc-event-dispatcher\n$dispatcher = new Dispatchers\\SymfonyImpl\\EventDispatcher($serializer, $endPoint);\n\n# Suppose we have a Symfony Event Listener and a Event Subscriber here\n$dispatcher->addListener('message.send', new SymfonyEventListener());\n$dispatcher->addSubscriber(new SymfonyEventSubscriber());\n\n# Dispatch a event 'message.send', the event will be sent to the EndPoint\n$dispatcher->dispatch(\n    'message.send',\n    new AsyncEvent(\n        [\n            'messageId'   => '1',\n            'messageBody' => 'abc'\n        ]\n    )\n);",
            "title": "Dispatcher"
        },
        {
            "location": "/dispatcher/#summary",
            "text": "Dispatcher is the user interface of tnc-event-dispatcher, It holds Serializer and EndPoint, binds Listeners, accepts Event and dispatches them to corresponding Listeners or EndPoint.  tnc-event-dispatcher  is gonna to have multiple Dispatcher implementations to adapte different frameworks. Currently only Symfony Event Dispatcher is implemented.",
            "title": "Summary"
        },
        {
            "location": "/dispatcher/#symfony-event-dispatcher",
            "text": "Symfony Event Dispatcher Implementation intends to replace the original symfony-event-dispatcher seamlessly. \nThey have similar user interface, Just some more extra options.",
            "title": "Symfony Event Dispatcher"
        },
        {
            "location": "/dispatcher/#define-a-event",
            "text": "For Event port, The original Events are fully supported without any changes. Just define the event and dispatch it. \nBut there are some more event types tnc-event-dispatcher supports. They are:   sync \n  works as same as origin event, the event will be dispatched to listeners directly.  sync_plus  \n  same as \"sync\" mode, except that after the event has been dispatched to local listeners, i will also send to EndPoint for remote listeners, but it will not be dispatched to local listeners again.  async \n  the event will be sent to EndPoint only, and after the receiver got it, will be dispatched to listeners.  both \n  the event will be dispatched to local listeners who are listening on the event name, and then send to EndPoint as well, after the receiver got it, will be dispatched to listeners who are listening on \"$eventName.async\"   Let's define a AsyncEvent, Which is as same as Symfony Event with implements TransportableEvent interface(have to implement getTransportMode method to specify the type of the Event).  <?php\nuse Symfony\\Component\\EventDispatcher\\Event;\nuse TNC\\EventDispatcher\\Interfaces\\Event\\TransportableEvent;\n\n/**\n * AsyncEvent will be send to the EndPoint\n */\nclass AsyncEvent extends Event implements TransportableEvent\n{\n    const NAME = 'message.send';\n\n    private $data = [];\n\n    public function __construct($data)\n    {\n        $this->data = $data;\n    }\n\n    /**\n     * Returns transport mode of this event\n     *\n     * It supports one of these:\n     *\n     *  - \"sync\"      works as same as origin event, the event will be dispatched to listeners directly.\n     *\n     *  - \"sync_plus\" same as \"sync\" mode, except that after the event has been dispatched to local listeners, i will\n     *                also send to EndPoint for remote listeners, but it will not be dispatched to local listeners\n     *                again.\n     *\n     *  - \"async\"     the event will be sent to EndPoint only, and after the receiver got it, will be dispatched to\n     *                listeners.\n     *\n     *  - \"both\"      the event will be dispatched to local listeners who are listening on the event name, and then\n     *                send to EndPoint as well, after the receiver got it, will be dispatched to listeners who are\n     *                listening on \"$eventName.async\"\n     *\n     * @see \\TNC\\EventDispatcher\\Interfaces\\Event\\TransportableEvent\n     *\n     * @return string\n     */\n    public function getTransportMode()\n    {\n        // TODO: Implement getTransportMode() method.\n    }\n}",
            "title": "Define a Event"
        },
        {
            "location": "/dispatcher/#dispatch-the-event",
            "text": "Dispatcher has totally same interface of symfony-event-dispatcher  <?php\n# Initialize tnc-event-dispatcher\n$dispatcher = new Dispatchers\\SymfonyImpl\\EventDispatcher($serializer, $endPoint);\n\n# Suppose we have a Symfony Event Listener and a Event Subscriber here\n$dispatcher->addListener('message.send', new SymfonyEventListener());\n$dispatcher->addSubscriber(new SymfonyEventSubscriber());\n\n# Dispatch a event 'message.send', the event will be sent to the EndPoint\n$dispatcher->dispatch(\n    'message.send',\n    new AsyncEvent(\n        [\n            'messageId'   => '1',\n            'messageBody' => 'abc'\n        ]\n    )\n);",
            "title": "Dispatch the Event"
        },
        {
            "location": "/serializer/",
            "text": "Summary\n\n\nSerializer is a core component of tnc-event-dispatcher, It helps to serilize Events to be transportable, Also unserilize Serialized-Events to be Event objects again.\n\n\nSerializer is inspired by \nSymfony Serializer\n, It also includes two parts, Normalizer and Formatter, The workflow like this: \n\n\n\n\nNormalizer takes care of transform Events to be a Array and the reverse, And Formatter is working on transform the Array to be a formatted string and the reverse, like Json, XML, ...\n\n\nExample\n\n\n<?php\nnamespace TNC\\EventDispatcher;\n\n# Specify Normalizers\n$supportedNormalizers = [\n    new Serialization\\Normalizers\\TNCActivityStreams\\TNCActivityStreamsWrappedEventNormalizer(),\n    new Serialization\\Normalizers\\TNCActivityStreams\\TNCActivityStreamsNormalizer()\n];\n\n# Specify Serialization Format\n$formatter  = new Serialization\\Formatters\\JsonFormatter();\n\n# Initialize Serializer\n$serializer = new Serializer($supportedNormalizers, $formatter);\n\n\n\n\nNormalizer\n\n\nActivityStreams Normalizers\n\n\nActivity Streams is a data format which defines a action, an activity consists of an actor, a verb, an an object, and a target. It tells the story of a person performing an action on or with an object. For more details please check their \nDocument\n\nTNC EventDispatcher internally providers \nActivityStreams\n Normalizers implementation.\n\n\nConventions\n\n\n\n\nEventName\n\n\nUse only lowercase letters, numbers, dots (.) and underscores (_);\n\n\nPrefix names with a namespace followed by a dot (e.g. order., user.*);\n\n\nEnd names with a verb that indicates what action it is (e.g. user.login, payment.subscribe).\n\n\n\n\nClasses\n\n\n\n\nTNC\\EventDispatcher\\Serialization\\Normalizers\\TNCActivityStreams\\TNCActivityStreamsWrappedEventNormalizer\n \n  Norlimize a WrappedEvent to be a Activity Streams Array or the reverse\n\n\n\n\n\n\n\n\n\n\nSupported Normalization\n\n\nSupported Denormalization\n\n\n\n\n\n\n\n\n\n\n$object instanceof WrappedEvent\n\n\n$className == WrappedEvent::class\n\n\n\n\n\n\n\n\n\n\nSerialization\\Normalizers\\TNCActivityStreams\\TNCActivityStreamsNormalizer\n\n  Norlimize a Event to be a Activity Streams Array or the reverse\n\n\n\n\n\n\n\n\n\n\nSupported Normalization\n\n\nSupported Denormalization\n\n\n\n\n\n\n\n\n\n\n$object instanceof TNCActivityStreamsEvent\n\n\nis_subclass_of($className, TNCActivityStreamsEvent::class)\n\n\n\n\n\n\n\n\nUsage\n\n\nIn tnc-event-dispatcher, ActivityStreams is supported by TNCActivityStreamsNormalizer.\n\n\nTNCActivityStreamsNormalizer only supports object which implements TNCActivityStreamsEvent interface(see above), If you check the source code of the Normalizer, it looks like this:\n\n\n<?php\nclass TNCActivityStreamsNormalizer {\n\n# ...    \n\n    public function supportsNormalization($object)\n    {\n        return ($object instanceof TNCActivityStreamsEvent);\n    }\n\n    public function supportsDenormalization($data, $className)\n    {\n        if (!class_exists($className)) {\n            return false;\n        }\n\n        return is_subclass_of($className, TNCActivityStreamsEvent::class);\n    }\n\n# ...        \n\n}\n\n\n\n\nSo a proper Event which wants to be normalized as ActivityStreams format, it have to implement TNCActivityStreamsEvent interface.\n\n\n<?php\nclass TestEvent implements TNCActivityStreamsEvent\n{\n    public function getTransportMode()\n\n    public function normalize(ActivityBuilderInterface $builder)\n\n    public function denormalize(Activity $activity)\n}\n\n\n\n\nWhen TNCActivityStreamsNormalizer do normalize, it will call the \"normalize\" method of the object, with a ActivityBuilderInterface implementation(default is DefaultActivityBuilder, can be changed as a constructor parameter of TNCActivityStreamsNormalizer).\nWhen do denormalize, it will call the \"denormalize\" method with a Activity instance(without call constructor), you can restore the Event here.\n\n\n<?php\n$normalizer = new TNCActivityStreamsNormalizer();\n$event = new TestEvent();\n\n$normalizedData = $normalizer->normalize($event);\n$restoredEvent = $normalizer->denormalize($normalizedData, TestEvent::class);\n\n\n\n\nDefaultActivityBuilder\n\n\nTNCActivityStreamsNormalizer come with a default ActivityBuilderInterface implementation which is DefaultActivityBuilder, it can be used to create a Activity. \n\nFor more usage, visit the test cases.\n\n\n<?php\n$builder = new DefaultActivityBuilder();\n\n# fill the Activity by array\n$builder->setFromArray([\n   'actor' => [\n     'objectType' => 'type2',\n     'id' => 'id4',\n     'content' => 'content',\n     'attachments' => [ # the rule of attachments is as same as ActivityObject\n       ['subtype1', 'subid1'],\n       'subid2',\n       [\n         'objectType' => 'subtype3',\n         'id' => 'subid3'\n       ]\n     ]\n   ]\n ]);\n\n# use methods\n$builder->setId('123');\n$builder->setVerb('message.send');\n$builder->setPublished('now');\n$builder->setActor((new ActivityObject())->setId('123'));\n...\n\n# get the built Activity\n$builder->getActivity();\n\n\n\n\nUser Cases\n\n\nCase1: benn logged in\n\n\n\n\nEvent\n\n\n\n\nI choose \"user.login\" as the EventName, Which is following the convention \"namespace.verb\"\n\n\nExample Code:\n\n\n<?php\nclass UserLoginEvent implements TNCActivityStreamsEvent\n{\n    const NAME = \"user.login\";\n\n    private $user = null;\n\n    public function __constructor(User $user) { $this->user = $user; }\n\n    public function getTransportMode() { return self::TRANSPORT_MODE_ASYNC; }\n\n    /**\n     * @param \\TNC\\EventDispatcher\\Serialization\\Normalizers\\TNCActivityStreams\\DefaultActivityBuilder $builder \n     */\n    public function normalize($builder)\n    {\n        $builder->setActor(\n          (new ActivityObject())->setObjectType('user')->setId($this->user->getId())\n        );\n        return $builder->getActivity();\n    }\n\n    /**\n     * @param \\TNC\\EventDispatcher\\Serialization\\Normalizers\\TNCActivityStreams\\Impl\\Activity $activity \n     */\n    public function denormalize($activity) \n    {\n        $this->user = UsersRepository::find($activity->getActor()->getId());\n    }\n}\n\n$dispatcher->dispatch(UserLoginEvent::NAME, new UserLoginEvent($user));\n\n\n\n\n\n\nFormatted Data (ActivityStreams)\n\n\n\n\n\n  \n\n    \ntitle\n\n    \nuser.login\n\n  \n\n  \n\n    \nverb\n\n    \nlogin\n\n  \n\n  \n\n    \nactor\n\n    \n{ objectType: \"user\", id: 123456 }\n\n  \n    \n  \n\n    \nid\n\n    \nGenerated Unique String\n\n  \n\n  \n\n    \npublished\n\n    \n2017-10-13T11:31:34+08:00\n\n  \n\n  \n\n    \nprovider\n\n    \n{ objectType: \"community\", id: \"Poppen\" }\n\n  \n\n  \n\n    \ngenerator\n\n    \n{ id: \"tnc-event-dispatcher\", content: { mode: \"async\", class: \"UserLoginEvent\" } }\n\n  \n\n\n\n\n\nCase2: benn visited \nfan's profile\n\n\nExample Code:\n\n\n<?php\nclass ProfileVisitEvent implements TNCActivityStreamsEvent\n{\n    const NAME = \"user.visit\";\n\n    private $visitor = null;\n    private $target = null;\n\n    public function __constructor(User $visitor, User $target) { \n        $this->visitor = $visitor;\n        $this->target = $target;\n    }\n\n    public function getTransportMode() { return self::TRANSPORT_MODE_ASYNC; }\n\n    /**\n     * @param \\TNC\\EventDispatcher\\Serialization\\Normalizers\\TNCActivityStreams\\DefaultActivityBuilder $builder \n     */\n    public function normalize($builder)\n    {\n        $builder->setFromArray(\n          [\n            'actor' => ['user', $this->visitor->getId()],\n            'object' => ['profile', $this->target->getName()]\n          ]\n        );\n        return $builder->getActivity();\n    }\n\n    /**\n     * @param \\TNC\\EventDispatcher\\Serialization\\Normalizers\\TNCActivityStreams\\Impl\\Activity $activity \n     */\n    public function denormalize($activity) \n    {\n        $this->visitor = UsersRepository::find($activity->getActor()->getId());\n        $this->target = UsersRepository::findByName($activity->getObject()->getId());\n    }\n}\n\n$dispatcher->dispatch(ProfileVisitEvent::NAME, new ProfileVisitEvent($visitor, $target));\n\n\n\n\n\n\nFormatted Data (ActivityStreams)\n\n\n\n\n\n  \n\n    \ntitle\n\n    \nuser.visit\n\n  \n\n  \n\n    \nverb\n\n    \nvisit\n\n  \n\n  \n\n    \nactor\n\n    \n{ objectType: \"user\", id: 12345 }\n\n  \n\n  \n\n    \nobject\n\n    \n{ objectType: \"profile\", id: \"fan\" }\n\n  \n\n  \n\n    \nid\n\n    \nGenerated Unique String\n\n  \n\n  \n\n    \npublished\n\n    \n2017-10-13T11:31:34+08:00\n\n  \n\n  \n\n    \nprovider\n\n    \n{ objectType: \"community\", id: \"Poppen\" }\n\n  \n\n  \n\n    \ngenerator\n\n    \n{ id: \"tnc-event-dispatcher\", content: { mode: \"async\", class: \"UserLoginEvent\" } }\n\n  \n\n\n\n\n\nCase3: benn sent a message \nto\n leo\n\n\nExample Code:\n\n\n<?php\nclass MessageSendEvent implements TNCActivityStreamsEvent\n{\n    const NAME = \"message.send\";\n\n    private $sender = null;\n    private $receiver = null;\n    private $message = null;\n\n    public function __constructor(User $sender, Message $message, User $receiver) { \n        $this->sender = $sender;\n        $this->message = $message;\n        $this->receiver = $receiver;\n    }\n\n    public function getTransportMode() { return self::TRANSPORT_MODE_ASYNC; }\n\n    /**\n     * @param \\TNC\\EventDispatcher\\Serialization\\Normalizers\\TNCActivityStreams\\DefaultActivityBuilder $builder \n     */\n    public function normalize($builder)\n    {\n        $builder->setFromArray(\n          [\n            'actor' => ['user', $this->visitor->getId()],\n            'object' => ['message', $this->message->getId()],\n            'target' => ['user', $this->receiver->getId()]\n          ]\n        );\n        return $builder->getActivity();\n    }\n\n    /**\n     * @param \\TNC\\EventDispatcher\\Serialization\\Normalizers\\TNCActivityStreams\\Impl\\Activity $activity \n     */\n    public function denormalize($activity) \n    {\n        $this->sender = UsersRepository::find($activity->getActor()->getId());\n        $this->message = UsersRepository::find($activity->getObject()->getId());\n        $this->receiver = UsersRepository::find($activity->getTarget()->getId());\n    }\n}\n\n$dispatcher->dispatch(MessageSendEvent::NAME, new MessageSendEvent($visitor, $target));\n\n\n\n\n\n\nFormatted Data (ActivityStreams)\n\n\n\n\n\n  \n\n    \ntitle\n\n    \nmessage.send\n\n  \n\n  \n\n    \nverb\n\n    \nsend\n\n  \n\n  \n\n    \nactor\n\n    \n{ objectType: \"user\", id: 12345 }\n\n  \n\n  \n\n    \nobject\n\n    \n{ objectType: \"message\", id: 112231 }\n\n  \n\n  \n\n      \ntarget\n\n      \n{ objectType: \"user\", id: 88929 }\n\n    \n\n  \n\n    \nid\n\n    \nGenerated Unique String\n\n  \n\n  \n\n    \npublished\n\n    \n2017-10-13T11:31:34+08:00\n\n  \n\n  \n\n    \nprovider\n\n    \n{ objectType: \"community\", id: \"Poppen\" }\n\n  \n\n  \n\n    \ngenerator\n\n    \n{ id: \"tnc-event-dispatcher\", content: { mode: \"async\", class: \"UserLoginEvent\" } }\n\n  \n\n\n\n\n\nFormatter\n\n\nJSON Formatter\n\n\nTNC\\EventDispatcher\\Serialization\\Formatters\\JsonFormatter",
            "title": "Serializer"
        },
        {
            "location": "/serializer/#summary",
            "text": "Serializer is a core component of tnc-event-dispatcher, It helps to serilize Events to be transportable, Also unserilize Serialized-Events to be Event objects again.  Serializer is inspired by  Symfony Serializer , It also includes two parts, Normalizer and Formatter, The workflow like this:    Normalizer takes care of transform Events to be a Array and the reverse, And Formatter is working on transform the Array to be a formatted string and the reverse, like Json, XML, ...",
            "title": "Summary"
        },
        {
            "location": "/serializer/#example",
            "text": "<?php\nnamespace TNC\\EventDispatcher;\n\n# Specify Normalizers\n$supportedNormalizers = [\n    new Serialization\\Normalizers\\TNCActivityStreams\\TNCActivityStreamsWrappedEventNormalizer(),\n    new Serialization\\Normalizers\\TNCActivityStreams\\TNCActivityStreamsNormalizer()\n];\n\n# Specify Serialization Format\n$formatter  = new Serialization\\Formatters\\JsonFormatter();\n\n# Initialize Serializer\n$serializer = new Serializer($supportedNormalizers, $formatter);",
            "title": "Example"
        },
        {
            "location": "/serializer/#normalizer",
            "text": "",
            "title": "Normalizer"
        },
        {
            "location": "/serializer/#activitystreams-normalizers",
            "text": "Activity Streams is a data format which defines a action, an activity consists of an actor, a verb, an an object, and a target. It tells the story of a person performing an action on or with an object. For more details please check their  Document \nTNC EventDispatcher internally providers  ActivityStreams  Normalizers implementation.",
            "title": "ActivityStreams Normalizers"
        },
        {
            "location": "/serializer/#conventions",
            "text": "EventName  Use only lowercase letters, numbers, dots (.) and underscores (_);  Prefix names with a namespace followed by a dot (e.g. order., user.*);  End names with a verb that indicates what action it is (e.g. user.login, payment.subscribe).",
            "title": "Conventions"
        },
        {
            "location": "/serializer/#classes",
            "text": "TNC\\EventDispatcher\\Serialization\\Normalizers\\TNCActivityStreams\\TNCActivityStreamsWrappedEventNormalizer  \n  Norlimize a WrappedEvent to be a Activity Streams Array or the reverse      Supported Normalization  Supported Denormalization      $object instanceof WrappedEvent  $className == WrappedEvent::class      Serialization\\Normalizers\\TNCActivityStreams\\TNCActivityStreamsNormalizer \n  Norlimize a Event to be a Activity Streams Array or the reverse      Supported Normalization  Supported Denormalization      $object instanceof TNCActivityStreamsEvent  is_subclass_of($className, TNCActivityStreamsEvent::class)",
            "title": "Classes"
        },
        {
            "location": "/serializer/#usage",
            "text": "In tnc-event-dispatcher, ActivityStreams is supported by TNCActivityStreamsNormalizer.  TNCActivityStreamsNormalizer only supports object which implements TNCActivityStreamsEvent interface(see above), If you check the source code of the Normalizer, it looks like this:  <?php\nclass TNCActivityStreamsNormalizer {\n\n# ...    \n\n    public function supportsNormalization($object)\n    {\n        return ($object instanceof TNCActivityStreamsEvent);\n    }\n\n    public function supportsDenormalization($data, $className)\n    {\n        if (!class_exists($className)) {\n            return false;\n        }\n\n        return is_subclass_of($className, TNCActivityStreamsEvent::class);\n    }\n\n# ...        \n\n}  So a proper Event which wants to be normalized as ActivityStreams format, it have to implement TNCActivityStreamsEvent interface.  <?php\nclass TestEvent implements TNCActivityStreamsEvent\n{\n    public function getTransportMode()\n\n    public function normalize(ActivityBuilderInterface $builder)\n\n    public function denormalize(Activity $activity)\n}  When TNCActivityStreamsNormalizer do normalize, it will call the \"normalize\" method of the object, with a ActivityBuilderInterface implementation(default is DefaultActivityBuilder, can be changed as a constructor parameter of TNCActivityStreamsNormalizer).\nWhen do denormalize, it will call the \"denormalize\" method with a Activity instance(without call constructor), you can restore the Event here.  <?php\n$normalizer = new TNCActivityStreamsNormalizer();\n$event = new TestEvent();\n\n$normalizedData = $normalizer->normalize($event);\n$restoredEvent = $normalizer->denormalize($normalizedData, TestEvent::class);",
            "title": "Usage"
        },
        {
            "location": "/serializer/#defaultactivitybuilder",
            "text": "TNCActivityStreamsNormalizer come with a default ActivityBuilderInterface implementation which is DefaultActivityBuilder, it can be used to create a Activity.  \nFor more usage, visit the test cases.  <?php\n$builder = new DefaultActivityBuilder();\n\n# fill the Activity by array\n$builder->setFromArray([\n   'actor' => [\n     'objectType' => 'type2',\n     'id' => 'id4',\n     'content' => 'content',\n     'attachments' => [ # the rule of attachments is as same as ActivityObject\n       ['subtype1', 'subid1'],\n       'subid2',\n       [\n         'objectType' => 'subtype3',\n         'id' => 'subid3'\n       ]\n     ]\n   ]\n ]);\n\n# use methods\n$builder->setId('123');\n$builder->setVerb('message.send');\n$builder->setPublished('now');\n$builder->setActor((new ActivityObject())->setId('123'));\n...\n\n# get the built Activity\n$builder->getActivity();",
            "title": "DefaultActivityBuilder"
        },
        {
            "location": "/serializer/#user-cases",
            "text": "",
            "title": "User Cases"
        },
        {
            "location": "/serializer/#case1-benn-logged-in",
            "text": "Event   I choose \"user.login\" as the EventName, Which is following the convention \"namespace.verb\"  Example Code:  <?php\nclass UserLoginEvent implements TNCActivityStreamsEvent\n{\n    const NAME = \"user.login\";\n\n    private $user = null;\n\n    public function __constructor(User $user) { $this->user = $user; }\n\n    public function getTransportMode() { return self::TRANSPORT_MODE_ASYNC; }\n\n    /**\n     * @param \\TNC\\EventDispatcher\\Serialization\\Normalizers\\TNCActivityStreams\\DefaultActivityBuilder $builder \n     */\n    public function normalize($builder)\n    {\n        $builder->setActor(\n          (new ActivityObject())->setObjectType('user')->setId($this->user->getId())\n        );\n        return $builder->getActivity();\n    }\n\n    /**\n     * @param \\TNC\\EventDispatcher\\Serialization\\Normalizers\\TNCActivityStreams\\Impl\\Activity $activity \n     */\n    public function denormalize($activity) \n    {\n        $this->user = UsersRepository::find($activity->getActor()->getId());\n    }\n}\n\n$dispatcher->dispatch(UserLoginEvent::NAME, new UserLoginEvent($user));   Formatted Data (ActivityStreams)   \n   \n     title \n     user.login \n   \n   \n     verb \n     login \n   \n   \n     actor \n     { objectType: \"user\", id: 123456 } \n       \n   \n     id \n     Generated Unique String \n   \n   \n     published \n     2017-10-13T11:31:34+08:00 \n   \n   \n     provider \n     { objectType: \"community\", id: \"Poppen\" } \n   \n   \n     generator \n     { id: \"tnc-event-dispatcher\", content: { mode: \"async\", class: \"UserLoginEvent\" } }",
            "title": "Case1: benn logged in"
        },
        {
            "location": "/serializer/#case2-benn-visited-fans-profile",
            "text": "Example Code:  <?php\nclass ProfileVisitEvent implements TNCActivityStreamsEvent\n{\n    const NAME = \"user.visit\";\n\n    private $visitor = null;\n    private $target = null;\n\n    public function __constructor(User $visitor, User $target) { \n        $this->visitor = $visitor;\n        $this->target = $target;\n    }\n\n    public function getTransportMode() { return self::TRANSPORT_MODE_ASYNC; }\n\n    /**\n     * @param \\TNC\\EventDispatcher\\Serialization\\Normalizers\\TNCActivityStreams\\DefaultActivityBuilder $builder \n     */\n    public function normalize($builder)\n    {\n        $builder->setFromArray(\n          [\n            'actor' => ['user', $this->visitor->getId()],\n            'object' => ['profile', $this->target->getName()]\n          ]\n        );\n        return $builder->getActivity();\n    }\n\n    /**\n     * @param \\TNC\\EventDispatcher\\Serialization\\Normalizers\\TNCActivityStreams\\Impl\\Activity $activity \n     */\n    public function denormalize($activity) \n    {\n        $this->visitor = UsersRepository::find($activity->getActor()->getId());\n        $this->target = UsersRepository::findByName($activity->getObject()->getId());\n    }\n}\n\n$dispatcher->dispatch(ProfileVisitEvent::NAME, new ProfileVisitEvent($visitor, $target));   Formatted Data (ActivityStreams)   \n   \n     title \n     user.visit \n   \n   \n     verb \n     visit \n   \n   \n     actor \n     { objectType: \"user\", id: 12345 } \n   \n   \n     object \n     { objectType: \"profile\", id: \"fan\" } \n   \n   \n     id \n     Generated Unique String \n   \n   \n     published \n     2017-10-13T11:31:34+08:00 \n   \n   \n     provider \n     { objectType: \"community\", id: \"Poppen\" } \n   \n   \n     generator \n     { id: \"tnc-event-dispatcher\", content: { mode: \"async\", class: \"UserLoginEvent\" } }",
            "title": "Case2: benn visited fan's profile"
        },
        {
            "location": "/serializer/#case3-benn-sent-a-message-to-leo",
            "text": "Example Code:  <?php\nclass MessageSendEvent implements TNCActivityStreamsEvent\n{\n    const NAME = \"message.send\";\n\n    private $sender = null;\n    private $receiver = null;\n    private $message = null;\n\n    public function __constructor(User $sender, Message $message, User $receiver) { \n        $this->sender = $sender;\n        $this->message = $message;\n        $this->receiver = $receiver;\n    }\n\n    public function getTransportMode() { return self::TRANSPORT_MODE_ASYNC; }\n\n    /**\n     * @param \\TNC\\EventDispatcher\\Serialization\\Normalizers\\TNCActivityStreams\\DefaultActivityBuilder $builder \n     */\n    public function normalize($builder)\n    {\n        $builder->setFromArray(\n          [\n            'actor' => ['user', $this->visitor->getId()],\n            'object' => ['message', $this->message->getId()],\n            'target' => ['user', $this->receiver->getId()]\n          ]\n        );\n        return $builder->getActivity();\n    }\n\n    /**\n     * @param \\TNC\\EventDispatcher\\Serialization\\Normalizers\\TNCActivityStreams\\Impl\\Activity $activity \n     */\n    public function denormalize($activity) \n    {\n        $this->sender = UsersRepository::find($activity->getActor()->getId());\n        $this->message = UsersRepository::find($activity->getObject()->getId());\n        $this->receiver = UsersRepository::find($activity->getTarget()->getId());\n    }\n}\n\n$dispatcher->dispatch(MessageSendEvent::NAME, new MessageSendEvent($visitor, $target));   Formatted Data (ActivityStreams)   \n   \n     title \n     message.send \n   \n   \n     verb \n     send \n   \n   \n     actor \n     { objectType: \"user\", id: 12345 } \n   \n   \n     object \n     { objectType: \"message\", id: 112231 } \n   \n   \n       target \n       { objectType: \"user\", id: 88929 } \n     \n   \n     id \n     Generated Unique String \n   \n   \n     published \n     2017-10-13T11:31:34+08:00 \n   \n   \n     provider \n     { objectType: \"community\", id: \"Poppen\" } \n   \n   \n     generator \n     { id: \"tnc-event-dispatcher\", content: { mode: \"async\", class: \"UserLoginEvent\" } }",
            "title": "Case3: benn sent a message to leo"
        },
        {
            "location": "/serializer/#formatter",
            "text": "",
            "title": "Formatter"
        },
        {
            "location": "/serializer/#json-formatter",
            "text": "",
            "title": "JSON Formatter"
        },
        {
            "location": "/serializer/#tnceventdispatcherserializationformattersjsonformatter",
            "text": "",
            "title": "TNC\\EventDispatcher\\Serialization\\Formatters\\JsonFormatter"
        },
        {
            "location": "/endpoint_and_receiver/",
            "text": "Summary\n\n\nEndPoint intends to be the place which holds/stores Events for a while, Usually it's a Queue Implementation, for example: RabbitMQ EndPoint, Redis EndPoint, Kafka EndPoint. In our company, we use our own \nEventBus\n as a EndPoint.\n\nReceiver is the reverse of EndPoint, It pulls Events from corresponding EndPoint and send it back to Dispatcher again. So it really depends what EndPoint is, there are also corresponding Receivers like: RabbitMQ Receover, Redis Receover, Kafka Receover, EventBus Receiver, ...\n\n\nEndPoint and Receiver is simple:\n\nAny class implements TNC\\EventDispatcher\\Interfaces\\EndPoint interface could be a EndPoint, \n\nAny class implements TNC\\EventDispatcher\\Interfaces\\Receiver could be a Receiver.\n\n\nImplementations\n\n\nEventBus\n\n\n\n\nEndPoint\n\n\n\n\n\n  \n\n    \nclass\nTNC\\EventDispatcher\\EndPoints\\EventBusEndPoint\n\n  \n\n  \n\n    \ndependencies\n\n    EventBus\n    \n\n  \n\n  \n\n    \narguments\n\n  \n\n\n\n\n\n\n\nReceiver\n\n\n\n\n\n  \n\n    \nclass\nTNC\\EventDispatcher\\Receivers\\EventBusReceiver\n\n  \n\n  \n\n    \ndependencies\n\n    EventBus\n    \n\n  \n\n  \n\n    \narguments\n\n  \n\n\n\n\n\nRedis\n\n\n\n\nEndPoint\n\n\n\n\n\n  \n\n    \nclass\nTNC\\EventDispatcher\\EndPoints\\Redis\\PHPRedisEndPoint\n\n  \n\n  \n\n    \ndependencies\n\n    Redis\n\n    PHPRedis\n    \n\n  \n\n  \n\n    \narguments\n\n  \n\n\n\n\n\n\n\nReceiver\n\n\n\n\nNot implemented yet\n\n\nRabbitMQ\n\n\n\n\nEndPoint\n\n\n\n\nNot implemented yet\n\n\n\n\nReceiver\n\n\n\n\nNot implemented yet\n\n\nKafka\n\n\n\n\nEndPoint\n\n\n\n\nNot implemented yet\n\n\n\n\nReceiver\n\n\n\n\nNot implemented yet",
            "title": "EndPoint & Receiver"
        },
        {
            "location": "/endpoint_and_receiver/#summary",
            "text": "EndPoint intends to be the place which holds/stores Events for a while, Usually it's a Queue Implementation, for example: RabbitMQ EndPoint, Redis EndPoint, Kafka EndPoint. In our company, we use our own  EventBus  as a EndPoint. \nReceiver is the reverse of EndPoint, It pulls Events from corresponding EndPoint and send it back to Dispatcher again. So it really depends what EndPoint is, there are also corresponding Receivers like: RabbitMQ Receover, Redis Receover, Kafka Receover, EventBus Receiver, ...  EndPoint and Receiver is simple: \nAny class implements TNC\\EventDispatcher\\Interfaces\\EndPoint interface could be a EndPoint,  \nAny class implements TNC\\EventDispatcher\\Interfaces\\Receiver could be a Receiver.",
            "title": "Summary"
        },
        {
            "location": "/endpoint_and_receiver/#implementations",
            "text": "",
            "title": "Implementations"
        },
        {
            "location": "/endpoint_and_receiver/#eventbus",
            "text": "EndPoint   \n   \n     class TNC\\EventDispatcher\\EndPoints\\EventBusEndPoint \n   \n   \n     dependencies \n    EventBus\n     \n   \n   \n     arguments \n      Receiver   \n   \n     class TNC\\EventDispatcher\\Receivers\\EventBusReceiver \n   \n   \n     dependencies \n    EventBus\n     \n   \n   \n     arguments",
            "title": "EventBus"
        },
        {
            "location": "/endpoint_and_receiver/#redis",
            "text": "EndPoint   \n   \n     class TNC\\EventDispatcher\\EndPoints\\Redis\\PHPRedisEndPoint \n   \n   \n     dependencies \n    Redis \n    PHPRedis\n     \n   \n   \n     arguments \n      Receiver   Not implemented yet",
            "title": "Redis"
        },
        {
            "location": "/endpoint_and_receiver/#rabbitmq",
            "text": "EndPoint   Not implemented yet   Receiver   Not implemented yet",
            "title": "RabbitMQ"
        },
        {
            "location": "/endpoint_and_receiver/#kafka",
            "text": "EndPoint   Not implemented yet   Receiver   Not implemented yet",
            "title": "Kafka"
        },
        {
            "location": "/change_logs/",
            "text": "v2.0.3\n\n\n\n\nImproved performance of EventBus EndPoint\n\n\nBugfixs & Improvements\n\n\nAdded EventBusSignal for giving some controls of how EventBus works\n\n\nAdded compatiable support for non json content\n\n\n\n\nv2.0.2\n\n\nImprove ActivityStreams Normalizers, For supporting some new fields: displayName, icon, image, updated, url\n\n\nv2.0.1\n\n\nBugfixs\n\n\nv2.0.0\n\n\nRefactored version from v1.x, Integrated with version 2.x of \nEventBus\n and Symfony 3.2+.\n\n\nv1.x\n\n\nFirst version of tnc-event-dispatcher, Integrated with version 1.x of \nEventBus\n and Symfony 1.x, Using long-term php process for Receiver.",
            "title": "Change Logs"
        },
        {
            "location": "/change_logs/#v203",
            "text": "Improved performance of EventBus EndPoint  Bugfixs & Improvements  Added EventBusSignal for giving some controls of how EventBus works  Added compatiable support for non json content",
            "title": "v2.0.3"
        },
        {
            "location": "/change_logs/#v202",
            "text": "Improve ActivityStreams Normalizers, For supporting some new fields: displayName, icon, image, updated, url",
            "title": "v2.0.2"
        },
        {
            "location": "/change_logs/#v201",
            "text": "Bugfixs",
            "title": "v2.0.1"
        },
        {
            "location": "/change_logs/#v200",
            "text": "Refactored version from v1.x, Integrated with version 2.x of  EventBus  and Symfony 3.2+.",
            "title": "v2.0.0"
        },
        {
            "location": "/change_logs/#v1x",
            "text": "First version of tnc-event-dispatcher, Integrated with version 1.x of  EventBus  and Symfony 1.x, Using long-term php process for Receiver.",
            "title": "v1.x"
        }
    ]
}